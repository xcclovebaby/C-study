#include <stdio.h>

/* 十六进制算法:
 *  十六进制转十进制:就用乘法，每一位乘以 16^0,16^1,16^2... 然后加在一起:
    * 例如:ff bf: A=10,B=11...F=15 (二进制从右往左数) 第一位f为15*16^0 + 11*16^1 + 15*16^2 + 15*16^3 = 65471

 * 十六进制转二进制:只需把每一位，变成二进制的四位数，然后拼在一起
    * 例如:ff bf(f=1111 b=1011) = 1111 1111 1011 1111
*/

/* 类型转换
 * 1.自动类型转换:由占用内存字节少的类型向占用字节多的类型转换
 * char/short -> signed int -> unsigned int -> long 整型转换
 * float -> double 浮点型转换
 * long -> double 整型转浮点型
 * 运算中默认使用占用字节大的类型做计算:
 * char/short/int 默认使用int型
 * int/long/float/double 默认使用double型
 * 2.强制类型转换:通过指定类型来实现转换
 * (类型)表达式
 * (int)x + y 表示把x+y的结果转换成整型
 */
void test1(){
    int a = -8;
    unsigned int b = 7;
    //当参与计算的类型中有无符号类型和有符号类型时,运算结果为无符号数
    if(a + b > 0){
        printf("a + b > 0 \n");
    }else {
        printf("a + b < 0 \n");
    }
    //这里验证输出a+b在无符号运算中 实际的值是多少 %u 表示输出十进制无符号整数
    printf("a + b = %u \n", a + b);
}

/* 位运算符
 * 1.& 按位与:任何值与0得0,与1保持不变 (用来使某位清零)
 * 0101 1011 &
 * 1011 0100
 * -----------
 * 0001 0000
 *
 * 2.| 按位或:任何值或1得1, 或0保持不变
 * 0101 0011 |
 * 1011 0100
 * -----------
 * 1111 0111
 *
 * 3.~ 按位取反:1变0,0变1
 * 0101 1101 ~
 * -----------
 * 1010 0010
 *
 * 4.^ 按位异或:相异得1,相同得0
 * 1001 1100 ^
 * 0101 1010
 * -----------
 * 1100 0110
 *
 * 5.>>右移/<<左移
 * 右移分为逻辑右移和算数右移
 * 逻辑右移低位溢出,高位补0
 * 0101 1010 >> 3
 * -----------
 * 0000 1011
 * 算数右移对有符号来说低位溢出,高位补符号位
 * 1010 1101 >> 3
 * -----------
 * 1111 0101
 * #算数右移对正数没有影响#
 *
 */
void test2(){
    printf("%d \n", -1 >> 3);
    /* -1 >> 3 输出结果为 -1
     * 解析:
     * -1的二进制原码 1000 0001
     * 反码(符号位不变,其他位取反)1111 1110
     * 补码(反码+1) 1111 1111
     * 计算 -1 >> 3
     * 1111 1111 >> 3
     * -----------
     * 1111 1111
     * 所以得出为算数右移,高位补符号位计算
     */
}

/* 逗号运算符 (..., ..., ...)
 * 例如 A = (B, C, D)
 * 先运行表达式B,再运行表达式C,最后运行表达式D, 最终A的值为表达式D的值
 */
void test3(){
    int a = 10, b = 20, c = 0;
    c = (a += 10, b += 10, a + b);
    printf("a = %d b = %d c = %d \n", a,b,c);
}

int main()
{
    test3();
    return 0;
}
