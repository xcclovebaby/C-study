#include <stdio.h>

/** ==========================
 * 本章所接触的内容，涉及到的内存都是虚拟内存
 * 学习目录：
 * 1.指针的定义
 * 2.指针和变量的关系
 * 3.指针的强制类型转换（重点）
 * 4.指针和数组的关系（重点）
 * 5.指针的运算
 * 6.指针数组
 * 7.多级指针（重点）
 * 8.字符串和指针
 * 9.数组指针
 * 10.函数与数组的传递
 * 11.函数指针
 * 12.void指针
 * ==========================*/

/** 内存以字节为单位存储数据,可以将程序中的虚拟寻址空间，看成一个很大的一维数组
 *  操作系统给每个存储单元分配了一个编号：0x00 00 00 00 ~ 0xff ff ff ff
 *  这个编号称之为地址
 *  指针就是地址
 *  指针变量：存放的是地址编号
 *  在32位系统下，地址总线是32位，所以地址是32位编号，即4个字节
 *
 *  注意1：无论什么类型的地址，都是存储单元的编号，任何类型的指针变量在32位系统下都是4字节
 *  注意2：对应类型的指针变量，只能存放对应类型的变量的地址。例：整型指针变量，只能存放整型变量的地址
 */

/** 1.指针的定义 */
/* 指针变量的定义方式：数据类型 * 指针变量名
 * int *p; 这就定义了一个int类型的指针p
 * 指针的运算符：&取地址 *取值
 */
void test1() {
    int *p; //定义一个int类型的指针p
    int a = 1000; //定义一个int类型变量a赋值100
    p = &a; //将a的地址赋值给指针p
    printf("\n test:");

    //获取变量的值,指针变量获取地址下存放的值
    printf("\n a = %d", a);
    printf("\n *p= %d", *p);

    //获取地址值
    printf("\n &a = %p", &a);
    printf("\n p= %p", p);
}

/** 2.指针和变量的关系 */
/* 指针可以存放变量的地址编号：
 * int a = 100;
 * int *p = &a; //这样就通过指针变量来引用变量
 */
void test2() {
    //注意*p1 *p2为int类型指针变量，temp/a/b都是int类型变量
    int *p1, *p2, temp, a, b;
    p1 = &a;
    p2 = &b;
    printf("\n 请输入a、b的值：\n");
    scanf("%d %d", p1, p2);
    printf("a = %d, b = %d \n", a, b);
    printf("*p1 = %d, *p2 = %d \n", *p1, *p2);

    //使用指针变量改变指针地址指向的数据
    temp = *p1;
    *p1 = *p2;
    *p2 = temp;
    printf("a = %d, b = %d \n", a, b);
    printf("*p1 = %d, *p2 = %d", *p1, *p2);

    //指针强制类型转换
}

/** 3.指针的强制类型转换 */
/* 对应类型的指针只能保存对应类型的数据地址
 * 如果想让不同类型的指针相互赋值时，需要强制类型转换
 */
void test3() {
    int a = 0x1234, b = 0x5678;
    char *p1, *p2;
    p1 = (char *)&a;
    p2 = (char *)&b;
    //获取数据值
    printf("a = %#x, b = %#x \n", a, b);
    printf("*p1 = %#x, *p2 = %#x \n", *p1, *p2);
    //获取地址值
    printf("&a = %p, &b = %p \n", &a, &b);
    printf("p1 = %p, p2 = %p \n", p1, p2);
    //移动指针指向
    p1++;
    p2++;
    printf("a = %#x, b = %#x \n", a, b);
    printf("*p1 = %#x, *p2 = %#x \n", *p1, *p2);
    //获取地址值
    printf("&a = %p, &b = %p \n", &a, &b);
    printf("p1 = %p, p2 = %p \n", p1, p2);
    /** 重点：
     *      int类型为4个字节，char类型为1个字节
     *      int a变量在内存中开辟了4个1字节的空间分别保存变量赋值的数据
     *      int *p = &a 获取内存地址只是获取到内存空间中第一个数据单元的地址,指针也只是保存第一个数据单元的地址
     *      如果将int类型强转为char类型，则只保留第一个数据单元的地址数据
     *      那么p1 = (char *)&a 强转类型后char *p1保存的&a第一个数据单元的地址，但因为数据类型的原因只能取值到1字节的数据
     *      内存开辟为连续空间，例如 int a = 0x1234 等于开辟了 0x0001 ~ 0x0004的内存单元
     *      char *p1指向为int a第一内存单元的数据，那么也可以移动指针指向 p1++
     *      低地址区保存的一般为低字节的数据
    */

}

/** 4.指针和数组的关系 */
/* 变量存放在内存中，有地址编号，定义的数组是多个相同类型变量的集合
 * 指针变量也可以存放数组元素的地址
 * 例如： int a[10]; int *p; p = &a[0];
 *
 * 只要将数组赋值给同类型的指针，那么指针变量与数组可以以相同方式操作
 */
/** 补充：C语言规定：数组的名字就是数组的首地址，即第0个元素的地址，是个常量 */
void test4() {
    //使用指针角标给数组中的某个元素进行赋值
    int a[10];
    int *p;
    p = a; //a数组的引用地址赋值给指针p
    p[2] = 100;
    //注意：a是常量，常量一旦被初始化，将无法被赋值。而p是指针变量可以进行赋值。
//   int b[10];
//   a = b; //这种是错误的

    //通过指针运算 加 取值的方式来引用数组的元素
    *(p + 2) = 10; //相当于a[2]或p[2], p是第0个元素的地址 p+2就是a[2]的地址。 *(p + 2) 即a[2]

    //只要将数组赋值给同类型的指针，那么指针变量与数组可以以相同方式操作
    printf("a[2] = %d \n", a[2]); //a[2] = 10
    printf("p[2] = %d \n", p[2]); //p[2] = 10
    printf("*(p + 2) = %d \n", *(p + 2)); //*(p + 2) = 10
    printf("*(a + 2) = %d \n", *(a + 2)); //*(a + 2) = 10
    printf("p = %p \n", p); //p = 0060FE68
    printf("p + 2 = %p \n", p + 2); //p + 2 = 0060FE70

    //既然指针和数组可以以相同方式操作，那么也可以通过指针来数组
    char *s = "123";
    int *i = {1,2,3,4,5};
    printf("*s = %c \n", *s); //*s = 1
    printf("s[0] = %c \n", s[0]); //s[0] = 1
    printf("*(s + 2) = %c \n", *(s + 2)); //*(s + 2) = 3
    printf("s[2] = %c \n", s[2]); //s[2] = 3
    printf("s = %p \n", s); //s = 004041B2
    printf("s + 2 = %p \n", s + 2); //s + 2 = 004041B4
}

/** 5.指针的运算 */
/* 指针可以加一个整数，移动的是指针指向内存单元角标最终还是地址。
 */
void test5() {
    int a[10];
    int *p, *q;
    p = a;
    q = p + 2;
    printf("p = %p \n", p); //p = 0060FE68
    printf("q = %p \n", q); //q = 0060FE70

    //两个相同类型的指针可以比较大小，指向前面元素的指针小于指向后面元素的指针
    if(p > q) {
        printf("p > q \n");
    }else if(q > p) {
        printf("q > p \n");
    } //q > p

    //两个相同类型的指针可以做减法，获取两个指针之间相差多少个元素
    printf("q - p = %d", q - p); //q - p = 2
}

/** 6.指针数组 */
/* 指针数组本身是个数组，是若干个相同类型的指针组成的集合
 * 定义方式：int *p[10]; 定义了一个长度为10的int类型的指针数组
 */
void test6() {
    char *name[5] = {"ABC", "DEF", "GHI", "JKL", "MNO"};
    for(int i = 0; i < sizeof(name) / sizeof(name[0]); i++) {
        printf("name[%d] = %s \n", i, name[i]);
    }
}

/** 7.指针的指针（多级指针）(重点) */
/* 指针的指针，就是指针的地址
 * int a = 0x1234;
 * int *p = &a; 一级指针
 * int **q = &p; 二级指针
 * int ***temp = &q; 三级指针
 * 多级指针在使用时 有多少级写多少*是代表取值，剩下均为取地址值
 * ***temp == **q == *p == a
 * **temp == *q == p == &a
 * *temp == q == &p
 * temp == &q
 */
void test7() {
    int a = 0x1234;
    //a == *p
    int *p = &a;

    //**q == *p == a;
    //*q == p;
    //q == &p;
    int **q;
    q = &p;

    //***m == **q == *p == a;
    //**m == *q == p;
    //*m == q;
    //m == &q;
    int ***m;
    m = &q;

    //    a = 0x1234 0x1234 0x1234 0x1234
    //    &a = 0060FE80 0060FE80 0060FE80 0060FE80
    //    &p = 0060FE84 0060FE84 0060FE84
    //    &q = 0060FE88 0060FE88
    //    &m = 0060FE8C

    printf("a = %#x %#x %#x %#x \n", ***m, **q, *p, a);
    printf("&a = %p %p %p %p \n", **m, *q, p, &a);
    printf("&p = %p %p %p \n", *m, q, &p);
    printf("&q = %p %p \n", m, &q);
    printf("&m = %p \n", &m);
}

/** 8.字符串和指针 */
/* 字符串是以'\0'结尾的若干个字符的集合
 * 字符串的存储形式：数组、指针、堆：
 * 数组：char name[3] = "ABC";
 *
 * 字符指针：char *name = "ABC";
 * 字符指针只存放了字符串的首字符的地址编号，"ABC"将放在文字常量区里
 * 这种形式的字符串是不能修改的！
 *
 * 堆：char *name = (char *)malloc(3 * sizeof(char)); 动态申请一个3字节的存储空间
 *    strcpy(name, "ABC"); //将字符串拷贝到name所指向的内存中
 *  malloc函数在堆区申请空间，再使用strcpy函数拷贝到堆区
 * 堆空间的内容可以修改
 *
 * 字符指针指向的内存能不能被修改,要看是否是指向字符串常量池
 * 如果指向字符串常量池则不能修改
 * 如果指向堆、栈、静态全局区的时候内容可以被修改
 */
void test8(){
   char *name = (char *)malloc(3 * sizeof(char));
   strcpy(name, "ABC");
   *name = 'y';
   name[1] = 'd';
   printf("%s", name);
}

/** 9.数组指针 */
/* 数组指针：本身是个指针，指向一个数组，加1指向下一个数组;
 * 数组指针的作用就是可以保存二维数组的首地址
 * 定义：int (*p)[5]; //定义了一个数组指针p，指向整型的有5个元素的数组
 *
 * 数组指针与指针数组的区别：
 * 数组指针：int (*p)[5];
 * 指针数组：int *p[5];
 *
 * 数组指针的用法是可以用来当做函数的形参来使用：
 * int a[3][5];
 * int x, y;
 * void fun(int (*p)[5], int x, int y)
 * fun(a,x,y);
 */
void test9() {
    int a[3][5];
    int (*p)[5];
    p = a;
    printf("a = %p \n", a);
    printf("p = %p \n", p);
    printf("a + 1 = %p \n", a + 1); //数组引用+1 是指向下一行数组
    printf("p + 1 = %p \n", p + 1);

    //二维数组的数组名降级
    printf("*a = %p \n", *a);
    a[0][1] = 123;
    printf("(*a) + 1 = %d \n", (*a) + 1); //这种方式是取同行的下一个元素地址
    printf("*((*a) + 1) = %d \n", *((*a) + 1)); //*((*a) + 1) = 123
}

/** 10.函数与数组的传递 */
//一维数组
void test10(int a[]){
    printf("test10: a = %p \n", a);
}
//二维数组
void test11(int (*p)[4]) {
    //拆分 *(p+1) 一维数组角标从[0] -> [1]拿到数组 {5,6,7,8}的地址, *(数组首地址 + 2) = b[1][2] = 7
    printf("test11: %d \n", *(*(p + 1) + 2));
}

//指针数组
void test12(char **q) {
    for(int i = 0; i < sizeof(q) / 1; i++) {
        printf("test12: %s \n", q[i]);
    }
}

//当函数的返回值是指针时，该函数被称为指针函数
char *test13() {
    //栈区开辟空前随着函数的结束而被释放，这时返回的地址值内的数据则被释放
    //char a[] = "1234";

    //这样定义，数据则会被一直保留
    static char a[] = "1234";
    return a;
}

/** 11.函数指针 */
/* 定义的函数在运行程序的时候，会将其指令加载到内存的代码段，所以函数也有起始地址
 * 函数的名字就是函数的首地址，即函数的入口地址
 * 可以通过定义一个指针来存放函数的地址，这个指针变量就是函数指针
 * 函数指针变量的定义方法：
 * int (*p)(int,int); //定义一个函数指针p，返回值为int，有两个int形参
 *
 * 将一个函数作为参数传递给另一个函数来使用，称为回调函数：
 * int sum(int a, int b) return a+b;
 * int sub(int a, int b) return a-b;
 * void test(int (*p)(int,int), int a, int b) p(a,b);
 */
int point1(int a, int b) {
    return a + b;
}

void test14() {
    int (*p)(int, int);
    p = point1;
    printf("test14: %d\n", p(1,2));
}

/** void指针 */
/* void *p指针的声明, 但不能直接使用 '*' 来取值
 * void *p; //p的类型为void *指针类型, 32位平台根据指针开辟4字节内存大小
 * p指针可以保存任意同*级类型
 * 使用p指针时必须先指定其类型
 */
void test15() {
    void *p;
    char ch;
    p = &ch; //char *
    float f;
    p = &f; //float *
    int num;
    p = &num; //int *

    //使用p指针时必须先指定其类型
    printf("test15: *p = %d \n", *(int *)p);
}

int main()
{
//    test1();
//    test2();
//    test3();
//    test4();
//    test5();
//    test6();
//    test7();
//    test8();
//    test9();
    int a[10];
    test10(a);

    int b[2][4] = {1,2,3,4,5,6,7,8};
    test11(b);

    char *q[5] = {"ABC","DEF","GHI"};
    test12(q);

    test14();

    test15();
    return 0;
}
